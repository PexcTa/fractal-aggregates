import streamlit as st
import numpy as np
from matplotlib import pyplot as plt
import plotly.graph_objects as go
from io import BytesIO
import os
from fractal_generator import (
    LinkedCellGrid,
    generate_fractal_aggregate,
    calculate_radius_of_gyration,
    calculate_shape_factor
)

# Function to export to XYZ format
def export_to_xyz(particles, filename="aggregate.xyz"):
    with open(filename, 'w') as f:
        f.write(f"{len(particles)}\n")
        f.write("Fractal aggregate generated by Streamlit app\n")
        for p in particles:
            pos = p['position']
            f.write(f"C {pos[0]:.6f} {pos[1]:.6f} {pos[2]:.6f}\n")
    return filename

# Tabs setup
tabs = st.tabs(["Introduction", "Single Aggregate", "Multiple Aggregates", "Agglomerates"])

with tabs[0]:
    st.title("Fractal Aggregate Generator")
    st.markdown("""
    ## Introduction to Fractal Aggregates
    
    This application generates 3D fractal aggregates using the Porous Eden Model.
                
    The algorithm is based on the one described in (1) Guesnet, E.; Dendievel, R.; Jauffrès, D.; Martin, C. L.; Yrieix, B. A Growth Model for the Generation of Particle Aggregates with Tunable Fractal Dimension. Physica A: Statistical Mechanics and its Applications 2019, 513, 63–73. https://doi.org/10.1016/j.physa.2018.07.061.

                
    ## This is a work in progress. "Single Aggregate" tab works.  
    
    ### Mathematical Background
    
    The radius of gyration $R_g$ characterizes the size of the aggregate:
    
    $R_g = \\frac{1}{N}\\sqrt{\\sum_{i<j} r_{ij}^2}$
    
    where $N$ is the number of particles and $r_{ij}$ is the distance between particles $i$ and $j$.
    
    The shape factor is calculated from the eigenvalues of the inertia tensor:
    
    $\\text{Shape Factor} = \\
    sqrt{\\frac{\\lambda_{\\text{max}}}{\\lambda_{\\text{min}}}}$
    
    where $\\lambda_{\\text{max}}$ and $\\lambda_{\\text{min}}$ are the maximum and minimum eigenvalues.
                
    ### To be continued... 
                
    """)

with tabs[1]:
    st.title("Single Aggregate Generator")
    
    # Two-column layout: parameters on left, visualization on right
    col_params, col_viz = st.columns([1, 2])
    
    with col_params:
        st.subheader("Generation Parameters")
        
        N = st.slider("Number of particles", 10, 5000, 500)
        st.caption("Total particles in the aggregate. Larger values increase computation time.")
        
        p = st.slider("Inactivation probability", 0.0, 1.0, 0.05)
        st.caption("Probability that a particle becomes inactive after growth. Higher values create more branched structures.")
        
        overlap = st.slider("Particle overlap", 0.0, 0.9, 0.0)
        st.caption("Fraction of particle diameter allowed to overlap. 0.0 = hard spheres.")
        
        cell_size = st.slider("Cell size", 2.0, 10.0, 4.0)
        st.caption("Spatial grid cell size for efficient collision detection.")
        
        radius = st.slider("Particle radius", 0.5, 5.0, 1.0)
        st.caption("Radius of individual particles in the aggregate.")
        
        if st.button("Generate Aggregate"):
            result = generate_fractal_aggregate(
                N=N,
                radius=radius,
                inactivation_probability=p,
                overlap=overlap,
                cell_size=cell_size,
                visualize=False
            )
            
            # Calculate metrics
            Rg = calculate_radius_of_gyration(result)
            sf = calculate_shape_factor(result)
            
            # Store in session state
            st.session_state.result = result
            st.session_state.Rg = Rg
            st.session_state.sf = sf
            st.session_state.particles = result['particles']
    
with col_viz:
    if 'result' in st.session_state:
        st.subheader("Visualization")
        
        viz_type = st.radio("Visualization type", ["Static point cloud", "Interactive 3D"])
        
        positions = np.array([p['position'] for p in st.session_state.result['particles']])
        radius = st.session_state.get('radius', 1.0)
        
        if viz_type == "Static point cloud":
            # Existing matplotlib code
            fig = plt.figure(figsize=(8, 6))
            ax = fig.add_subplot(111, projection='3d')
            scatter = ax.scatter(positions[:,0], positions[:,1], positions[:,2], s=1, c='blue', alpha=0.8)
            ax.set_box_aspect([1,1,1])
            ax.set_xlabel('X')
            ax.set_ylabel('Y')
            ax.set_zlabel('Z')
            plt.tight_layout()
            st.pyplot(fig)
            
        else:  # Interactive 3D
            fig = go.Figure()
            positions = np.array([p['position'] for p in st.session_state.result['particles']])
            
            if len(positions) <= 100:  # Only render solid spheres for small aggregates
                # Create Icosahedron mesh for each sphere (better performance than np.outer)
                phi = (1 + np.sqrt(5)) / 2
                vertices = np.array([
                    [-1,  phi, 0], [1,  phi, 0], [-1, -phi, 0], [1, -phi, 0],
                    [0, -1,  phi], [0, 1,  phi], [0, -1, -phi], [0, 1, -phi],
                    [phi, 0, -1], [phi, 0, 1], [-phi, 0, -1], [-phi, 0, 1]
                ])
                faces = np.array([
                    [0, 11, 5], [0, 5, 1], [0, 1, 7], [0, 7, 10], [0, 10, 11],
                    [1, 5, 9], [5, 11, 4], [11, 10, 2], [10, 7, 6], [7, 1, 8],
                    [3, 9, 4], [3, 4, 2], [3, 2, 6], [3, 6, 8], [3, 8, 9],
                    [4, 9, 5], [2, 4, 11], [6, 2, 10], [8, 6, 7], [9, 8, 1]
                ])
                
                # Normalize vertices
                vertices = vertices / np.linalg.norm(vertices, axis=1)[:, None]
                
                for pos in positions:
                    # Scale and translate vertices
                    verts = vertices * radius + pos
                    fig.add_trace(go.Mesh3d(
                        x=verts[:,0], y=verts[:,1], z=verts[:,2],
                        i=faces[:,0], j=faces[:,1], k=faces[:,2],
                        color='blue',
                        opacity=0.8,
                        flatshading=True,
                        lighting=dict(ambient=0.5, diffuse=0.8, specular=0.2, roughness=0.6),
                        lightposition=dict(x=100, y=0, z=200)
                    ))
            else:
                # Use large scatter points for larger aggregates
                fig.add_trace(go.Scatter3d(
                    x=positions[:,0], y=positions[:,1], z=positions[:,2],
                    mode='markers',
                    marker=dict(
                        size=5 * radius,  # Scale marker size with particle radius
                        color='royalblue',
                        opacity=0.8
                    )
                ))
            
            fig.update_layout(
                scene=dict(
                    xaxis_title='X',
                    yaxis_title='Y',
                    zaxis_title='Z',
                    aspectmode='data'  # Better aspect ratio
                ),
                margin=dict(l=0, r=0, b=0, t=0),
                scene_camera=dict(eye=dict(x=1.5, y=1.5, z=1.5))
            )
            st.plotly_chart(fig, use_container_width=True)
        
        # Metrics below visualization
        st.subheader("Aggregate Metrics")
        col1, col2 = st.columns(2)
        col1.metric("Radius of Gyration", f"{st.session_state.Rg:.4f}")
        col2.metric("Shape Factor", f"{st.session_state.sf:.4f}")
        
        # Save XYZ button
        if st.button("Save XYZ"):
            filename = export_to_xyz(st.session_state.particles)
            with open(filename, "rb") as f:
                st.download_button(
                    label="Download XYZ file",
                    data=f,
                    file_name=filename,
                    mime="text/plain"
                )
            st.success(f"Saved to {filename}")