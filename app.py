import streamlit as st
import numpy as np
from matplotlib import pyplot as plt
import plotly.graph_objects as go
from io import BytesIO
import os
from fractal_generator import (
    LinkedCellGrid,
    generate_fractal_aggregate,
    calculate_radius_of_gyration,
    calculate_shape_factor,
    calculate_porosity,
    calculate_structure_factor
)

# Function to export to XYZ format
def export_to_xyz(particles, filename="aggregate.xyz"):
    with open(filename, 'w') as f:
        f.write(f"{len(particles)}\n")
        f.write("Fractal aggregate generated by Streamlit app\n")
        for p in particles:
            pos = p['position']
            f.write(f"C {pos[0]:.6f} {pos[1]:.6f} {pos[2]:.6f}\n")
    return filename

# Tabs setup
tabs = st.tabs(["Introduction", "Single Aggregate", "Multiple Aggregates", "Agglomerates"])

with tabs[0]:
    st.title("Fractal Aggregate Generator")
    st.markdown("""
    ## Introduction (Work in Progress)
    
    Particles aggregate. It's what they do. They might form separately and stick together, like soot does, or they might grow on top of each other, like cancer tumours. The pattern of aggregation determines morphology, and morphology can be critically important for real-world properties, like mobility in the environment. Sometimes, it's important to be able to describe and simulate particle aggregates.
    There are a few approaches towards simulating aggregation. A few excellent introductory articles and reviews are listed below in the Bibliography section.$^{1-3}$
    The code under the hood of this app is based on the Porous Eden model as described by Guesnet et al.$^4$ The approach is agnostic of physics. In other words, it is purely geometry-based. The simulated structures are mainly useful for scattering data analysis. They are also aesthetically pleasing.         

    ### The Algorithm 

    Describe the algorithm here.
    
    ### Relevant Mathematical Background
    
    The radius of gyration $R_g$ characterizes the size of the aggregate:
    
    $R_g = \\frac{1}{N}\\sqrt{\\sum_{i<j} r_{ij}^2}$
    
    where $N$ is the number of particles and $r_{ij}$ is the distance between particles $i$ and $j$.
    
    The shape factor is calculated from the eigenvalues of the inertia tensor:
    
    $\\text{Shape Factor} = \\
    sqrt{\\frac{\\lambda_{\\text{max}}}{\\lambda_{\\text{min}}}}$
    
    where $\\lambda_{\\text{max}}$ and $\\lambda_{\\text{min}}$ are the maximum and minimum eigenvalues.
                
    ### References
    [4] Guesnet, E.; Dendievel, R.; Jauffrès, D.; Martin, C. L.; Yrieix, B. A Growth Model for the Generation of Particle Aggregates with Tunable Fractal Dimension. Physica A: Statistical Mechanics and its Applications 2019, 513, 63–73. https://doi.org/10.1016/j.physa.2018.07.061.
                
    ### About the Author
    This application was developed by Boris V. Kramar, PhD, while at Lomonosov Moscow State University (Radiochemistry division).
    The algorithm is largely based on that described by Guesnet et al.$^4$ Much of the boilerplate code was written using an LLM-based assisant (Qwen3-Max). 
    The full version of this code was used for a project on amorphous thorium dioxide. You can read the paper once it's published! There will be a link here: 
    Visit Boris's personal website here: <link TBA>
                
    """)

with tabs[1]:
    st.title("Single Aggregate Generator")
    
    # Two-column layout: parameters on left, visualization on right
    col_params, col_viz = st.columns([1, 2])
    
    with col_params:
        st.subheader("Generation Parameters")
        
        N = st.slider("Number of particles", 10, 5000, 500, key='sin_agg_N')
        st.caption("Total particles in the aggregate. Larger values increase computation time.")
        
        p = st.slider("Inactivation probability", 0.0, 1.0, 0.05, key='sin_agg_p')
        st.caption("Probability that a particle becomes inactive after growth. Higher values create more branched structures.")
        
        overlap = st.slider("Particle overlap", 0.0, 0.9, 0.0, key='sin_agg_ove')
        st.caption("Fraction of particle diameter allowed to overlap. 0.0 = hard spheres.")
        
        cell_size = st.slider("Cell size", 2.0, 10.0, 4.0, key='sin_agg_cellsize')
        st.caption("Spatial grid cell size for efficient collision detection.")
        
        radius = st.slider("Particle radius", 0.5, 5.0, 1.0, key='sin_agg_rad')
        st.caption("Radius of individual particles in the aggregate.")
        
        if st.button("Generate Aggregate"):
            result = generate_fractal_aggregate(
                N=N,
                radius=radius,
                inactivation_probability=p,
                overlap=overlap,
                cell_size=cell_size,
                visualize=False
            )
            
            # Calculate metrics
            Rg = calculate_radius_of_gyration(result)
            sf = calculate_shape_factor(result)
            
            # Store in session state
            st.session_state.result = result
            st.session_state.Rg = Rg
            st.session_state.sf = sf
            st.session_state.radius = radius
    
    # Visualization section (outside button handler)
    with col_viz:
        if 'result' in st.session_state:
            st.subheader("Visualization")
            
            viz_type = st.radio("Visualization type", ["Static point cloud", "Interactive 3D (for N<201)"])
            
            positions = np.array([p['position'] for p in st.session_state.result['particles']])
            radius = st.session_state.get('radius', 1.0)
            
            if viz_type == "Static point cloud":
                # Existing matplotlib code
                fig = plt.figure(figsize=(8, 6))
                ax = fig.add_subplot(111, projection='3d')
                scatter = ax.scatter(positions[:,0], positions[:,1], positions[:,2], s=10, c='blue', alpha=0.8)
                ax.set_box_aspect([1,1,1])
                ax.set_proj_type('persp', focal_length=0.25)
                ax.set_xlabel('X')
                ax.set_ylabel('Y')
                ax.set_zlabel('Z')
                plt.tight_layout()
                st.pyplot(fig)
                
            else:  # Interactive 3D
                fig = go.Figure()
                
                if len(positions) <= 200:  # Only render proper spheres for small aggregates
                    def ms(x, y, z, radius, resolution=10):
                        """Return coordinates for plotting a sphere centered at (x,y,z)"""
                        u, v = np.mgrid[0:2*np.pi:resolution*2j, 0:np.pi:resolution*1j]
                        X = radius * np.cos(u) * np.sin(v) + x
                        Y = radius * np.sin(u) * np.sin(v) + y
                        Z = radius * np.cos(v) + z
                        return (X, Y, Z)
                    
                    # Create a surface for each particle
                    for pos in positions:
                        x_s, y_s, z_s = ms(pos[0], pos[1], pos[2], radius, resolution=8)
                        fig.add_trace(go.Surface(
                            x=x_s, y=y_s, z=z_s,
                            colorscale=[[0, 'dodgerblue'], [1, 'dodgerblue']],
                            opacity=1,
                            showscale=False,
                        ))
                else:
                    # For larger aggregates, use scatter with size based on radius
                    fig.add_trace(go.Scatter3d(
                        x=positions[:,0], y=positions[:,1], z=positions[:,2],
                        mode='markers',
                        marker=dict(
                            size=16 * radius,  # Scale marker size by particle radius
                            color='dodgerblue',
                            opacity=0.9,
                            line=dict(
                                color='black', # Edge color
                                width=4                # Edge width in pixels
                            )
                        )
                    ))
                
                fig.update_layout(
                    scene=dict(
                        xaxis_title='X',
                        yaxis_title='Y',
                        zaxis_title='Z',
                        aspectmode='data'
                    ),
                    margin=dict(l=0, r=0, b=0, t=0),
                    scene_camera=dict(eye=dict(x=1.5, y=1.5, z=1.5))
                )
                st.plotly_chart(fig, use_container_width=True)
            
            # Metrics below visualization
            st.subheader("Aggregate Metrics")
            col1, col2 = st.columns(2)
            col1.metric("Radius of Gyration", f"{st.session_state.Rg:.4f}")
            col2.metric("Shape Factor", f"{st.session_state.sf:.4f}")
            
            # Save XYZ button
            if st.button("Save XYZ"):
                filename = export_to_xyz(st.session_state.result['particles'])
                with open(filename, "rb") as f:
                    st.download_button(
                        label="Download XYZ file",
                        data=f,
                        file_name=filename,
                        mime="text/plain"
                    )
                st.success(f"Saved to {filename}")

with tabs[2]:
    st.title("Multiple Aggregates Generator")
    
    # Parameters
    col1, col2 = st.columns(2)
    with col1:
        num_aggregates = st.slider("Number of aggregates", 1, 50, 5)
        N = st.slider("Particles per aggregate", 10, 1000, 100)
        p = st.slider("Inactivation probability", 0.0, 1.0, 0.05)
    with col2:
        overlap = st.slider("Particle overlap", 0.0, 0.9, 0.0)
        cell_size = st.slider("Cell size", 2.0, 10.0, 4.0)
        radius = st.slider("Particle radius", 0.5, 5.0, 1.0)
    
    if st.button("Generate Multiple Aggregates"):
        with st.spinner("Generating aggregates... This may take a while for large N."):
            results = []
            metrics = {
                'Rg': [], 
                'shape_factor': [], 
                'df_v2': [],  # Mass fractal dimension
                'porosity': []  # Porosity
            }
            
            for i in range(num_aggregates):
                seed = 42 + i
                result = generate_fractal_aggregate(
                    N=N,
                    radius=radius,
                    inactivation_probability=p,
                    overlap=overlap,
                    cell_size=cell_size,
                    random_seed=seed,
                    visualize=False
                )
                Rg = calculate_radius_of_gyration(result)
                sf = calculate_shape_factor(result)
                
                # Calculate mass fractal dimension
                try:
                    _, _, _, df_v2, _, _, _ = calculate_structure_factor(
                        result, 
                        R_particle=radius,
                        q_min=0.01,
                        q_max=10.0,
                        n_q=50
                    )
                except Exception as e:
                    df_v2 = np.nan
                
                # Calculate porosity
                try:
                    porosity, _, _ = calculate_porosity(result, particle_radius=radius)
                except Exception as e:
                    porosity = np.nan
                
                results.append(result)
                metrics['Rg'].append(Rg)
                metrics['shape_factor'].append(sf)
                metrics['df_v2'].append(df_v2)
                metrics['porosity'].append(porosity)
            
            st.session_state.multiple_results = results
            st.session_state.multiple_metrics = metrics
            
            # Show metrics distributions (4 histograms)
            fig, axs = plt.subplots(2, 2, figsize=(12, 8))
            fig.suptitle(f'Distributions for {num_aggregates} aggregates (N={N})', fontsize=14)
            
            # Radius of Gyration
            axs[0, 0].hist(metrics['Rg'], bins=10, alpha=0.7, color='blue')
            axs[0, 0].set_title('Radius of Gyration (Rg)')
            axs[0, 0].set_xlabel('Rg')
            axs[0, 0].set_ylabel('Frequency')
            
            # Shape Factor
            axs[0, 1].hist(metrics['shape_factor'], bins=10, alpha=0.7, color='orange')
            axs[0, 1].set_title('Shape Factor')
            axs[0, 1].set_xlabel('Shape Factor')
            axs[0, 1].set_ylabel('Frequency')
            
            # Mass Fractal Dimension (df_v2)
            valid_df_v2 = [x for x in metrics['df_v2'] if not np.isnan(x)]
            if valid_df_v2:
                axs[1, 0].hist(valid_df_v2, bins=10, alpha=0.7, color='green')
                axs[1, 0].set_title('Mass Fractal Dimension (df)')
                axs[1, 0].set_xlabel('df')
                axs[1, 0].set_ylabel('Frequency')
                axs[1, 0].set_xlim(1.0, 3.0)  # Typical fractal dimension range
            
            # Porosity
            valid_porosity = [x for x in metrics['porosity'] if not np.isnan(x)]
            if valid_porosity:
                axs[1, 1].hist(valid_porosity, bins=10, alpha=0.7, color='red')
                axs[1, 1].set_title('Porosity')
                axs[1, 1].set_xlabel('Porosity (ϵ)')
                axs[1, 1].set_ylabel('Frequency')
                axs[1, 1].set_xlim(0.0, 1.0)
            
            plt.tight_layout()
            st.pyplot(fig)
            
            # Summary statistics
            st.subheader("Summary Statistics")
            
            col1, col2, col3, col4 = st.columns(4)
            col1.metric("Mean Rg", f"{np.mean(metrics['Rg']):.4f}")
            col2.metric("Mean Shape Factor", f"{np.mean(metrics['shape_factor']):.4f}")
            
            if valid_df_v2:
                col3.metric("Mean Mass Fractal Dim", f"{np.mean(valid_df_v2):.4f}")
            else:
                col3.warning("No valid df values")
                
            if valid_porosity:
                col4.metric("Mean Porosity", f"{np.mean(valid_porosity):.4f}")
            else:
                col4.warning("No valid porosity values")
    
    # Aggregate Visualization Section
    if 'multiple_results' in st.session_state:
        st.markdown("---")
        st.subheader("Aggregate Visualization")
        st.caption("Select an aggregate to visualize based on its properties")
        
        col1, col2, col3 = st.columns(3)
        
        with col1:
            metric_selection = st.selectbox("Sort by metric", 
                                           ["Shape Factor", "Radius of Gyration (Rg)", "Mass Fractal Dimension (df)"])
        
        with col2:
            sort_direction = st.radio("Direction", ["Lowest", "Highest"])
        
        with col3:
            viz_type_agg = st.radio("Visualization type", ["Static point cloud", "Interactive 3D"])
        
        if st.button("Visualize Selected Aggregate"):
            # Find the index of the aggregate to visualize
            metrics_list = st.session_state.multiple_metrics
            if metric_selection == "Shape Factor":
                values = metrics_list['shape_factor']
            elif metric_selection == "Radius of Gyration (Rg)":
                values = metrics_list['Rg']
            else:  # Mass Fractal Dimension
                values = metrics_list['df_v2']
            
            # Filter out NaN values and get valid indices
            valid_indices = [i for i, v in enumerate(values) if not np.isnan(v)]
            valid_values = [values[i] for i in valid_indices]
            
            if not valid_values:
                st.error("No valid values available for the selected metric.")
            else:
                # Find the index to visualize
                if sort_direction == "Lowest":
                    idx_to_visualize = valid_indices[np.argmin(valid_values)]
                else:
                    idx_to_visualize = valid_indices[np.argmax(valid_values)]
                
                # Get the selected aggregate
                selected_aggregate = st.session_state.multiple_results[idx_to_visualize]
                selected_metric_value = valid_values[np.argmin(valid_values)] if sort_direction == "Lowest" else valid_values[np.argmax(valid_values)]
                
                # Store in session state for visualization
                st.session_state.selected_aggregate = {
                    'particles': selected_aggregate['particles'],
                    'parameters': selected_aggregate.get('parameters', {}),
                    'metrics': {
                        'shape_factor': metrics_list['shape_factor'][idx_to_visualize],
                        'Rg': metrics_list['Rg'][idx_to_visualize],
                        'df_v2': metrics_list['df_v2'][idx_to_visualize],
                        'porosity': metrics_list['porosity'][idx_to_visualize]
                    },
                    'metric_name': metric_selection,
                    'metric_value': selected_metric_value,
                    'sort_direction': sort_direction
                }
        
        # Display the visualization if an aggregate has been selected
        if 'selected_aggregate' in st.session_state:
            selected = st.session_state.selected_aggregate
            st.subheader(f"Aggregate with {sort_direction} {metric_selection}")
            st.caption(f"Value: {selected['metric_value']:.4f}")
            
            # Get particle positions
            positions = np.array([p['position'] for p in selected['particles']])
            radius = selected['parameters'].get('radius', 1.0)
            
            if viz_type_agg == "Static point cloud":
                # Static visualization using matplotlib
                fig = plt.figure(figsize=(8, 6))
                ax = fig.add_subplot(111, projection='3d')
                ax.scatter(positions[:,0], positions[:,1], positions[:,2], s=10, c='blue', alpha=0.8)
                ax.set_box_aspect([1,1,1])
                ax.set_proj_type('persp', focal_length=0.25)
                ax.set_xlabel('X')
                ax.set_ylabel('Y')
                ax.set_zlabel('Z')
                plt.tight_layout()
                st.pyplot(fig)
                
            else:  # Interactive 3D
                # Interactive visualization using Plotly
                fig = go.Figure()
                if len(positions) <= 50:
                    def ms(x, y, z, radius, resolution=8):
                        """Return coordinates for plotting a sphere centered at (x,y,z)"""
                        u, v = np.mgrid[0:2*np.pi:resolution*2j, 0:np.pi:resolution*1j]
                        X = radius * np.cos(u) * np.sin(v) + x
                        Y = radius * np.sin(u) * np.sin(v) + y
                        Z = radius * np.cos(v) + z
                        return (X, Y, Z)
                    
                    for pos in positions:
                        x_s, y_s, z_s = ms(pos[0], pos[1], pos[2], radius, resolution=8)
                        fig.add_trace(go.Surface(
                            x=x_s, y=y_s, z=z_s,
                            colorscale=[[0, 'dodgerblue'], [1, 'dodgerblue']],
                            opacity=1.0,
                            showscale=False,
                            #lighting=dict(ambient=0.5, diffuse=0.8, specular=0.5),
                            #lightposition=dict(x=100, y=200, z=0)
                        ))
                else:
                    fig.add_trace(go.Scatter3d(
                        x=positions[:,0], y=positions[:,1], z=positions[:,2],
                        mode='markers',
                        marker=dict(
                            size=16 * radius,
                            color='dodgerblue',
                            opacity=0.9,
                            line=dict(
                            color='black', # Edge color
                            width=4                # Edge width in pixels
                            )
                        )
                    ))
                
                fig.update_layout(
                    scene=dict(
                        xaxis_title='X',
                        yaxis_title='Y',
                        zaxis_title='Z',
                        aspectmode='data'
                    ),
                    margin=dict(l=0, r=0, b=0, t=0),
                    scene_camera=dict(eye=dict(x=1.5, y=1.5, z=1.5))
                )
                st.plotly_chart(fig, use_container_width=True)
                
            # Display metrics for the selected aggregate
            st.subheader("Selected Aggregate Metrics")
            col1, col2, col3, col4 = st.columns(4)
            col1.metric("Shape Factor", f"{selected['metrics']['shape_factor']:.4f}")
            col2.metric("Rg", f"{selected['metrics']['Rg']:.4f}")
            col3.metric("Mass Fractal Dim", f"{selected['metrics']['df_v2']:.4f}")
            col4.metric("Porosity", f"{selected['metrics']['porosity']:.4f}")

            # After the visualization section, add this code:

            col1, col2 = st.columns(2)

            with col1:
                if 'selected_aggregate' in st.session_state and st.button("Save XYZ (Selected)"):
                    selected = st.session_state.selected_aggregate
                    filename = f"aggregate_{selected['sort_direction']}_{selected['metric_name'].replace(' ', '_')}.xyz"
                    
                    # Create XYZ content
                    xyz_content = f"{len(selected['particles'])}\n"
                    xyz_content += "Fractal aggregate generated by Streamlit app\n"
                    for p in selected['particles']:
                        pos = p['position']
                        xyz_content += f"C {pos[0]:.6f} {pos[1]:.6f} {pos[2]:.6f}\n"
                    
                    st.download_button(
                        label="Download Selected Aggregate",
                        data=xyz_content,
                        file_name=filename,
                        mime="text/plain"
                    )

            with col2:
                if 'multiple_results' in st.session_state and st.button("Save All (ZIP)"):
                    import zipfile
                    from io import BytesIO
                    
                    zip_buffer = BytesIO()
                    with zipfile.ZipFile(zip_buffer, "w") as zip_file:
                        for i, result in enumerate(st.session_state.multiple_results):
                            # Create XYZ content
                            xyz_content = f"{len(result['particles'])}\n"
                            xyz_content += f"Fractal aggregate #{i+1} from batch generation\n"
                            for p in result['particles']:
                                pos = p['position']
                                xyz_content += f"C {pos[0]:.6f} {pos[1]:.6f} {pos[2]:.6f}\n"
                            
                            # Add to zip
                            zip_file.writestr(f"aggregate_{i+1}.xyz", xyz_content)
                    
                    st.download_button(
                        label="Download All Aggregates (ZIP)",
                        data=zip_buffer.getvalue(),
                        file_name="all_aggregates.zip",
                        mime="application/zip"
                    )