import streamlit as st
import numpy as np
from matplotlib import pyplot as plt
import plotly.graph_objects as go
from io import BytesIO
import time
import os
from fractal_generator import (
    ParticleLevelGrid,
    AggregateLevelGrid,
    generate_fractal_aggregate,
    calculate_radius_of_gyration,
    calculate_shape_factor,
    calculate_porosity,
    calculate_structure_factor,
    generate_agglomerate,
)

# widescreen view
st.set_page_config(layout="wide")

# Function to export to XYZ format
def export_to_xyz(particles, filename="aggregate.xyz"):
    with open(filename, 'w') as f:
        f.write(f"{len(particles)}\n")
        f.write("Fractal aggregate generated by Streamlit app\n")
        for p in particles:
            pos = p['position']
            f.write(f"C {pos[0]:.6f} {pos[1]:.6f} {pos[2]:.6f}\n")
    return filename

# Tabs setup
tabs = st.tabs(["Introduction", "The Algorithm and the Math", "Single Aggregate", "Multiple Aggregates", "Agglomerates"])

with tabs[0]:
    col1, col2, col3 = st.columns([1,4,1])
    with col2:
        st.title("Porous Eden Mass Fractal Aggregate Generator")
        
        st.markdown("""
        ## Introduction (Work in Progress)
        
        Small particles aggregate. It's what they do. They might form separately and stick together, like soot does, or they might grow on top of each other, like cancer tumours. The pattern of aggregation determines morphology, and morphology can be critically important for real-world properties, like mobility in the environment. Sometimes, it's important to be able to describe and simulate particle aggregates.
        
        Aggregation often forms fractal structures. The word structure is used in a broad sense here: patterns can be fractal too. A true fractal is an object that appears the same regardless of the magnification scale. It is pretty obvious that true infinite fractals do not exist in nature, because everything has a boundary. However, there are some systems the fractal character of which is easily observed. 
                    
        Take, for example, the coastline problem. The image below depicts the isle of Kolguyev (Courtesy of Google Maps). The island was first *formally* explored by the English explorer and ornithologist Aubyn Trevor-Battye in 1894, but has been inhabited for much longer than that by the ingidenous Nenets people.""")
        
        st.image("images/kolguev.png", caption="The island of Kolguyev in the Russian Arctic", width=750, )

        st.markdown("""
                    
        Trevor-Battye spent a lot of time trying to approach Kolguyev and got a pretty good view of its western shores. If I tasked Trevor-Battye (or you, the reader) with measuring the total coastline of Kolguyev, the usual approach would be to imagine some sort of an envelope that contains all of Kolguyev
        and measure its perimeter. The problem, however, is that if you zoom in on the island, you will find that your envelope won't properly capture its jagged shores:""")

        st.image("images/zoomin.png", caption="It looks beautiful there. Trevor-Battye landed a little further to the north.", width=750, )

        st.markdown("""
        See that? There is a big, wet-looking section where making an outline of the coast is quite challenging. If we keep zooming in, we will find more nooks and crannies. 
                    
        And if you zoom in on the nooks and crannnies, you will, perhaps, find rocks (or icy sheets) with jagged edges. And if you zoom in on the edges, you will find cracks. 
                    
        Eventually, you hit crystal faces, defects, single atoms; you go through multiple large steps in scale and yet you'll see very similar images with edges, cracks, irregularities, and your envelope will get ever tighter, and, as a result, larger. There is an end to it somewhere, but, suffice it to say, the fractal character of the coastline means it has to be approximated to some degree, by some convention. 

        In that sense, the coastline of a landmass is very much a fractal solid. Now instead of looking at a map and thinking about how the coastline breaks down into smaller and smaller features, think of small particles coming together to form big structures. Same concept, viewed bottom-up.
                    
        You'll see that if you have particles aggregating into larger particles, fractal character arises naturally. The larger particle - the aggregate - may look like, for example, a sphere, but, if you zoom in, you'll find smaller particles. This application will let you experiment with generating mass fractal aggregates. For more information on mass fractal aggregates, the mathematics, and the algorithm used in this application, please go to the **"The Algorithm and the Math"** tab. Otherwise, feel free to check out the simulation sections.""")
                
with tabs[1]:
    col1, col2, col3 = st.columns([1,4,1])
    with col2:
        st.markdown("""

        ## On Fractal Aggregates

        ### Terminology

        Let us define a *particle* as a bit of matter. For the purposes of this discussion, let us consider spherical particles with an arbitrary radius R. 
                    
        In that case, an *aggregate* is a collection of particles sticking together. The algorithm used in this web application does not take interaction energy into account (indeed, there is no physical knowledge utilised). Therefore, we will not make any assumptions about the force causing particles to stick. 
        
        Another important term is an *agglomerate*. The distinction between aggregates and agglomerates is not exactly consistent; one common way to draw it is to state that aggregates arise from strong interactions, and agglomerates from weak interactions. This exercise, as stated above, does not have an interaction energy scale. Instead, we will define an agglomerate as a collection of aggregates. This will be explained below.
        
        Any aggregate is defined as containing a given number of particles. The number of particles per aggregate, *z*, will be referred to as the *degree of aggregation*.
        
        It is easy to see that aggregation of particles produces rough interfaces. A rough interface is any interface that presents inhomogeneities, irregularities, empty spaces interspersed with solid material, i.e. any interface that is not perfectly smooth. If you would like to prove to yourself that aggregating particles will always produce at least some roughness, try the following exercise: take a sheet of paper, choose a flat particle shape, and try to "tile" the sheet with that shape such that there are no gaps between your particles. You will find that there is a limited number of shapes you can use (and a circle is not among them). 
                    
        Broadly speaking, rough fractal interfaces can be divided into two categories: *surface fractals* and *mass fractals*. A surface fractal is a mass presenting surface roughness but no internal voids, i.e. it only appears fractal at the surface. A mass fractal is a material that exhibits fractal properties throughout the volume it occupies. The image below illustrates the distinction.
                    
        Fractal type is determined by a numerical quantity known as the fractal dimension. This application is meant to generate mass fractals; however, occasionally surface fractals will also be observed. 

        By definition, mass fractals are porous. Porosity is a quantity that describes how much of a particle's volume is just empty space. When we talk of a particle volume here, we mean the volume of its envelope. If you haven't encountered the concept of envelope volume before, one easy way to visualise it is by looking at your coffee cup. The envelope volume of a coffee cup is the combination of the solid cup and the maximum quantity of liquid it may contain.
                    
        Our particles will be spherical, but the aggregates can take very diverse shapes. It can be useful to understand the shape of an aggregate. One metric to do so is the *shape factor*, which, in essence, tells us how much does the shape deviate from a perfect sphere.
                    
        The basic version of the algorithm is written for *monodisperse* particles. Monodispersity means that all the particles are of the same size and shape. Monodispersity is a useful simplifying assumption.
        
        ### The Algorithm  
        
        There are a few approaches towards simulating aggregation. A few excellent introductory articles and reviews are listed below in the Bibliography section.$^{1-3}$
        
        The code under the hood of this app is based on the Porous Eden model as described by Guesnet et al.$^4$ The approach is agnostic of physics. In other words, it is purely geometry-based. The simulated structures are mainly useful for scattering data analysis. They are also aesthetically pleasing.

        The description below is taken directly from Guesnet et al.$^4$ with added commentary. 
        
        **1. A particle is chosen randomly among active ones.**
                    
        **2. A growth direction is chosen randomly.**
                    
        **3. If there is enough space in this direction, a new particle is added in contact.**
                    
        **4. The chosen particle may be turned inactive with an inactivation probability p.**
                    
        **5. The process is iterated until a specified number of particles N is reached.**
                    
        So, after picking a particle, we compute a random 3D unit vector and check that there is enough space in that direction. If there is not enough space, we choose a new unit vector. Unlike the Guesnet et al. implementation described in the paper, frustrated attempts, i.e. attempts leading to particle overlap, are not allowed, unless the user chooses to allow partial overlap of particles. (This will make sense when you see the control sliders on the tabs to follow). Once a new particle is added, the particle we chose to add *to* may randomly turn inactive, which means that it will not serve as an attachment point again. The inactivation probability
        is one of the key parameters in this algorithm. If the inactivation probability is very high, say, 0.9+, then there is a good chance that most particles will be chosen for a new attachment only once before being deactivated. 
        Consequently, high values of inactivation probability lead to high branching. You will be able to experiment with this yourself. The figures below illustrate the point being made.
                    
        Generated aggregates are aesthetically pleasing and fun to investigate. For them to be of scientific use, we need to introduce some mathematical metrics we will use to describe them. 
        
        ### Relevant Mathematical Background
        
        The radius of gyration $R_g$ characterizes the size of the aggregate:
        
        $R_g = \\frac{1}{N}\\sqrt{\\sum_{i<j} r_{ij}^2}$
        
        where $N$ is the number of particles and $r_{ij}$ is the distance between particles $i$ and $j$.
        
        The shape factor is calculated from the eigenvalues of the inertia tensor:
        
        $\\text{Shape Factor} = \\
        sqrt{\\frac{\\lambda_{\\text{max}}}{\\lambda_{\\text{min}}}}$
        
        where $\\lambda_{\\text{max}}$ and $\\lambda_{\\text{min}}$ are the maximum and minimum eigenvalues.
                    
        ### References
        [1] Meakin, P. Fractal Aggregates. Advances in Colloid and Interface Science 1987, 28, 249–331. https://doi.org/10.1016/0001-8686(87)80016-7.
       
        [2] Meakin, P. A Historical Introduction to Computer Models for Fractal Aggregates. Journal of Sol-Gel Science and Technology 1999, 15 (2), 97–117. https://doi.org/10.1023/A:1008731904082.
     
        [3] Tomchuk, O. Models for Simulation of Fractal-like Particle Clusters with Prescribed Fractal Dimension. Fractal and Fractional 2023, 7 (12), 866. https://doi.org/10.3390/fractalfract7120866.
        
        [4] Guesnet, E.; Dendievel, R.; Jauffrès, D.; Martin, C. L.; Yrieix, B. A Growth Model for the Generation of Particle Aggregates with Tunable Fractal Dimension. Physica A: Statistical Mechanics and its Applications 2019, 513, 63–73. https://doi.org/10.1016/j.physa.2018.07.061.
                    
        ### About the Author
        This application was developed by Boris V. Kramar, PhD, while at Lomonosov Moscow State University (Radiochemistry division).
        The algorithm is largely based on that described by Guesnet et al.$^4$ Much of the boilerplate code was written using an LLM-based assisant (Qwen3-Max). 
        The full version of this code was used for a project on amorphous thorium dioxide. You can read the paper once it's published! There will be a link here: 
        Visit Boris's personal website here: <link TBA>
                    
        """)

def get_colors(color_opt, particles, total_N):
    """Get colors based on selection option, normalized to total_N"""
    if color_opt == "blue":
        return ['blue'] * len(particles)
    elif color_opt == "addition order":
        steps = np.array([p['added_step'] for p in particles])
        # Normalize against total_N, not current max
        norm_steps = steps / total_N if total_N > 0 else steps
        # Get RGBA values from colormap
        colors = plt.cm.magma(norm_steps)
        # Ensure we have 4 values per color (RGBA)
        if colors.ndim == 1 and len(colors) == 4:
            colors = np.array([colors])  # Handle single color case
        elif colors.shape[1] == 3:  # RGB only
            colors = np.hstack([colors, np.ones((len(colors), 1))])  # Add alpha=1
        return colors
    elif color_opt == "activity":
        colors = []
        for p in particles:
            colors.append('orange' if not p.get('inactive', False) else 'gray')
        return colors
    return ['blue'] * len(particles)

def plot_static(positions, color_opt, particles, particle_radius, total_N):
    fig = plt.figure(figsize=(6, 6))
    ax = fig.add_subplot(111, projection='3d')
    
    colors = get_colors(color_opt, particles, total_N)
    
    scatter = ax.scatter(
        positions[:,0], positions[:,1], positions[:,2],
        c=colors, s=particle_radius*20, alpha=0.8
    )
    ax.set_box_aspect([1,1,1])
    ax.set_xlabel('X')
    ax.set_ylabel('Y')
    ax.set_zlabel('Z')
    
    # Add legends based on color mode
    if color_opt == "blue":
        ax.legend(['particle'], loc='upper right')
    elif color_opt == "addition order":
        # Create colorbar
        sm = plt.cm.ScalarMappable(cmap=plt.cm.magma, 
                                 norm=plt.Normalize(vmin=0, vmax=1))
        sm.set_array([])
        cbar = plt.colorbar(sm, ax=ax, shrink=0.5)
        cbar.set_ticks([0, 1])
        cbar.set_ticklabels(['oldest', 'newest'])
    elif color_opt == "activity":
        from matplotlib.lines import Line2D
        legend_elements = [
            Line2D([0], [0], marker='o', color='w', markerfacecolor='orange', markersize=8, label='Active'),
            Line2D([0], [0], marker='o', color='w', markerfacecolor='gray', markersize=8, label='Inactive')
        ]
        ax.legend(handles=legend_elements, loc='upper right')
    
    return fig

def plot_plotly_points(positions, color_opt, particles, radius, total_N):
    fig = go.Figure()
    
    if color_opt == "activity":
        # Create separate traces for active/inactive particles
        active_mask = np.array([not p.get('inactive', False) for p in particles])
        inactive_mask = ~active_mask
        
        if np.any(active_mask):
            fig.add_trace(go.Scatter3d(
                x=positions[active_mask,0], y=positions[active_mask,1], z=positions[active_mask,2],
                mode='markers',
                marker=dict(size=8 * radius, color='orange', opacity=0.8),
                name='Active'
            ))
        if np.any(inactive_mask):
            fig.add_trace(go.Scatter3d(
                x=positions[inactive_mask,0], y=positions[inactive_mask,1], z=positions[inactive_mask,2],
                mode='markers',
                marker=dict(size=8 * radius, color='gray', opacity=0.8),
                name='Inactive'
            ))
    else:
        # Get colors using the same method as plot_plotly_spheres()
        colors = get_colors(color_opt, particles, total_N)
        
        # Convert to format Plotly needs
        color_strings = []
        for c in colors:
            if isinstance(c, (tuple, list, np.ndarray)):
                rgba_str = f'rgba({c[0]*255:.0f},{c[1]*255:.0f},{c[2]*255:.0f},{c[3]:.2f})'
                color_strings.append(rgba_str)
            else:
                color_strings.append(c)
        
        # Single trace for other color modes
        fig.add_trace(go.Scatter3d(
            x=positions[:,0], y=positions[:,1], z=positions[:,2],
            mode='markers',
            marker=dict(
                size=8 * radius,
                color=color_strings,
                opacity=0.8,
                line=dict(color='black', width=0.5)
            ),
            name='particle' if color_opt == "blue" else None,
            showlegend=(color_opt == "blue")
        ))
        
        # Add colorbar if needed
        if color_opt == "addition order":
            colorbar_trace = go.Scatter3d(
                x=[None], y=[None], z=[None],
                mode='markers',
                marker=dict(
                    colorscale="Magma",
                    cmin=0,
                    cmax=1,
                    color=[0, 1],
                    showscale=True,
                    colorbar=dict(
                        title="Addition Order",
                        tickvals=[0, 1],
                        ticktext=["oldest", "newest"]
                    )
                ),
                showlegend=False,
                hoverinfo='none'
            )
            fig.add_trace(colorbar_trace)
    
    fig.update_layout(
        scene=dict(
            xaxis_title='X',
            yaxis_title='Y',
            zaxis_title='Z',
            aspectmode='data'
        ),
        margin=dict(l=0, r=0, b=0, t=0),
        scene_camera=dict(eye=dict(x=1.5, y=1.5, z=1.5))
    )
    return fig

def plot_plotly_spheres(positions, color_opt, particles, radius, total_N):
    fig = go.Figure()
    
    colors = get_colors(color_opt, particles, total_N)
    
    def ms(x, y, z, radius, resolution=8):
        u, v = np.mgrid[0:2*np.pi:resolution*2j, 0:np.pi:resolution*1j]
        X = radius * np.cos(u) * np.sin(v) + x
        Y = radius * np.sin(u) * np.sin(v) + y
        Z = radius * np.cos(v) + z
        return (X, Y, Z)
    
    if color_opt == "activity":
        # Separate traces for active/inactive
        active_mask = np.array([not p.get('inactive', False) for p in particles])
        inactive_mask = ~active_mask
        
        if np.any(active_mask):
            for pos in positions[active_mask]:
                x_s, y_s, z_s = ms(pos[0], pos[1], pos[2], radius, resolution=8)
                fig.add_trace(go.Surface(
                    x=x_s, y=y_s, z=z_s,
                    colorscale=[[0, 'orange'], [1, 'orange']],
                    opacity=1,
                    showscale=False,
                    name='Active',
                    showlegend=True
                ))
        if np.any(inactive_mask):
            for pos in positions[inactive_mask]:
                x_s, y_s, z_s = ms(pos[0], pos[1], pos[2], radius, resolution=8)
                fig.add_trace(go.Surface(
                    x=x_s, y=y_s, z=z_s,
                    colorscale=[[0, 'gray'], [1, 'gray']],
                    opacity=1,
                    showscale=False,
                    name='Inactive',
                    showlegend=True
                ))
    else:
        # Properly convert all colors to rgba strings
        color_strings = []
        for c in colors:
            if isinstance(c, (tuple, list, np.ndarray)):
                # Convert matplotlib RGBA (0-1) to rgba string
                rgba_str = f'rgba({c[0]*255:.0f},{c[1]*255:.0f},{c[2]*255:.0f},{c[3]:.2f})'
                color_strings.append(rgba_str)
            else:
                color_strings.append(c)
        
        # Single color mode or addition order
        for i, pos in enumerate(positions):
            x_s, y_s, z_s = ms(pos[0], pos[1], pos[2], radius, resolution=8)
            fig.add_trace(go.Surface(
                x=x_s, y=y_s, z=z_s,
                colorscale=[[0, color_strings[i]], [1, color_strings[i]]],
                opacity=1,
                showscale=False,
                name='particle' if color_opt == "blue" else None,
                showlegend=(color_opt == "blue")
            ))
        
        # Add colorbar for addition order mode
        if color_opt == "addition order":
            fig.add_trace(go.Scatter3d(
                x=[None], y=[None], z=[None],
                mode='markers',
                marker=dict(
                    color=[0, 1],
                    colorscale="Magma",
                    cmin=0,
                    cmax=1,
                    colorbar=dict(
                        title="Addition Order",
                        tickvals=[0, 1],
                        ticktext=["oldest", "newest"]
                    ),
                    showscale=True
                ),
                showlegend=False
            ))
    
    fig.update_layout(
        scene=dict(
            xaxis_title='X',
            yaxis_title='Y',
            zaxis_title='Z',
            aspectmode='data'
        ),
        margin=dict(l=0, r=0, b=0, t=0),
        scene_camera=dict(eye=dict(x=1.5, y=1.5, z=1.5))
    )
    return fig


with tabs[2]:
    st.title("Single Aggregate Generator")
    
    # Parameters column
    with st.expander("Generation Parameters", expanded=True):
        st.subheader("Generation Parameters")
        N = st.slider("Number of particles", 10, 5000, 500, key='sin_agg_N')
        st.caption("Total number of particles in the aggregate. Larger N increases aggregate size and computation time.")
        p = st.slider("Inactivation probability", 0.0, 0.9999, 0.0, key='sin_agg_p')
        st.caption("The probability to inactivate a particle after another one attaches. Large p increases branching.")
        overlap = st.slider("Particle overlap", 0.0, 0.9, 0.0, key='sin_agg_ove')
        st.caption("The degree to which particles are allowed to overlap. At overlap = 0, particles are hard spheres.")
        radius = st.slider("Particle radius", 0.1, 10.0, 1.0, key='sin_agg_rad')
        st.caption("Particle radius. Unitless because all metrics are scaled to the same units. Meaningful if you plan to work in q-space.")
        cell_size = st.slider("Cell size", 0.1, 40.0, 4.0, key='sin_agg_cellsize')
        st.caption("The size of the cell in the grid for neighbor search. Affects computation time. Should be about 2x-4x the radius.")
        
        if st.button("Generate Aggregate", type="primary"):
            result = generate_fractal_aggregate(
                N=N,
                radius=radius,
                inactivation_probability=p,
                overlap=overlap,
                cell_size=cell_size,
                visualize=False
            )
            Rg = calculate_radius_of_gyration(result)
            sf = calculate_shape_factor(result)
            
            st.session_state.result = result
            st.session_state.Rg = Rg
            st.session_state.sf = sf
            st.session_state.radius = radius
    
    # Two-column visualization layout
    if 'result' in st.session_state:
        col_vis1, col_vis2 = st.columns(2)
        total_N = st.session_state.result.get('total_N', len(st.session_state.result['particles']))
        # Growth stage visualization
        with col_vis1:
            st.subheader("Growth Stage")
            growth_stage = st.slider("Growth stage (%)", 0, 100, 50, key="growth_slider")
            stage_idx = int(growth_stage / 100 * (len(st.session_state.result['intermediate_states']) - 1))
            current_state = st.session_state.result['intermediate_states'][stage_idx]
            
            # Visualization options
            viz_type1 = st.selectbox("Visualization type", 
                                    ["Static point cloud", "3D point cloud", "3D spheres (N<201)"],
                                    key="viz1")
            color_opt1 = st.selectbox("Color by", ["blue", "addition order", "activity"], key="color1")
            
            positions1 = np.array([p['position'] for p in current_state])
            if viz_type1 == "Static point cloud":
                fig = plot_static(positions1, color_opt1, current_state, particle_radius=radius, total_N = total_N)
                st.pyplot(fig)
            elif viz_type1 == "3D point cloud":
                fig = plot_plotly_points(positions1, color_opt1, current_state, st.session_state.radius, total_N = total_N)
                st.plotly_chart(fig, use_container_width=True, key='tab1col1chartv1')
            else:  # 3D spheres
                if len(positions1) <= 200:
                    fig = plot_plotly_spheres(positions1, color_opt1, current_state, st.session_state.radius, total_N = total_N)
                    st.plotly_chart(fig, use_container_width=True, key='tab1col1chartv2')
                else:
                    st.warning("This type of visualisation is not currently supported for an aggregate composed of more than 200 particles. Please choose a different type of visualisation or generate a different aggregate")
        
        # Final aggregate visualization
        with col_vis2:
            st.subheader("Final Aggregate")
            viz_type2 = st.selectbox("Visualization type", 
                                    ["Static point cloud", "3D point cloud", "3D spheres (N<201)"],
                                    key="viz2")
            color_opt2 = st.selectbox("Color by", ["blue", "addition order", "activity"], key="color2")
            
            positions2 = np.array([p['position'] for p in st.session_state.result['particles']])
            if viz_type2 == "Static point cloud":
                fig = plot_static(positions2, color_opt2, st.session_state.result['particles'], particle_radius=radius, total_N = total_N)
                st.pyplot(fig)
            elif viz_type2 == "3D point cloud":
                fig = plot_plotly_points(positions2, color_opt2, st.session_state.result['particles'], st.session_state.radius, total_N = total_N)
                st.plotly_chart(fig, use_container_width=True, key='tab1col2chartv1')
            else:  # 3D spheres
                if len(positions2) <= 200:
                    fig = plot_plotly_spheres(positions2, color_opt2, st.session_state.result['particles'], st.session_state.radius, total_N = total_N)
                    st.plotly_chart(fig, use_container_width=True, key='tab1col2chartv2')
                else:
                    st.warning("This type of visualisation is not currently supported for an aggregate composed of more than 200 particles. Please choose a different type of visualisation or generate a different aggregate")
        
        # Metrics below visualizations
        st.markdown("---")
        st.subheader("Aggregate Metrics")
        col1, col2 = st.columns(2)
        col1.metric("Radius of Gyration", f"{st.session_state.Rg:.4f}")
        col2.metric("Shape Factor", f"{st.session_state.sf:.4f}")
        
        # Save XYZ button
        if st.button("Save XYZ"):
            filename = export_to_xyz(st.session_state.result['particles'])
            with open(filename, "rb") as f:
                st.download_button(
                    label="Download XYZ file",
                    data=f,
                    file_name=filename,
                    mime="text/plain"
                )
            st.success(f"Saved to {filename}")

with tabs[3]:
    st.title("Multiple Aggregates Generator")
    
    # Parameters
    with st.expander("Generation Parameters"):
            
        col1, col2 = st.columns(2)
        with col1:
            num_aggregates = st.slider("Number of aggregates", 1, 500, 5)
            st.caption("Total number of aggregates to generate. Larger values increase computation time.")
            N = st.slider("Particles per aggregate", 10, 1000, 100)
            st.caption("Total number of particles in the aggregate. Larger values increase aggregate size and computation time.")
            p = st.slider("Inactivation probability", 0.0, 1.0, 0.05)
            st.caption("The probability to inactivate a particle after another one attaches. Large p increases branching.")
        with col2:
            overlap = st.slider("Particle overlap", 0.0, 0.9, 0.0)
            st.caption("The degree to which particles are allowed to overlap. At overlap = 0, particles are hard spheres.")
            cell_size = st.slider("Cell size", 2.0, 10.0, 4.0)
            st.caption("The size of the cell in the grid for neighbor search. Affects computation time. Should be about 2x-4x the radius.")
            radius = st.slider("Particle radius", 0.5, 5.0, 1.0)
            st.caption("Particle radius. Unitless because all metrics are scaled to the same units. Meaningful if you plan to work in q-space.")
        
        if st.button("Generate Multiple Aggregates"):
            with st.spinner("Generating aggregates... This may take a while for large N."):
                results = []
                metrics = {
                    'Rg': [], 
                    'shape_factor': [], 
                    'df_v2': [],  # Mass fractal dimension
                    'porosity': []  # Porosity
                }
                
                for i in range(num_aggregates):
                    seed = 42 + i
                    result = generate_fractal_aggregate(
                        N=N,
                        radius=radius,
                        inactivation_probability=p,
                        overlap=overlap,
                        cell_size=cell_size,
                        random_seed=seed,
                        visualize=False
                    )
                    Rg = calculate_radius_of_gyration(result)
                    sf = calculate_shape_factor(result)
                    
                    # Calculate mass fractal dimension
                    try:
                        _, _, _, df_v2, _, _, _ = calculate_structure_factor(
                            result, 
                            R_particle=radius,
                            q_min=0.01,
                            q_max=10.0,
                            n_q=50
                        )
                    except Exception as e:
                        df_v2 = np.nan
                    
                    # Calculate porosity
                    try:
                        porosity, _, _ = calculate_porosity(result, particle_radius=radius)
                    except Exception as e:
                        porosity = np.nan
                    
                    results.append(result)
                    metrics['Rg'].append(Rg)
                    metrics['shape_factor'].append(sf)
                    metrics['df_v2'].append(df_v2)
                    metrics['porosity'].append(porosity)
                
                st.session_state.multiple_results = results
                st.session_state.multiple_metrics = metrics
                st.session_state.num_aggregates = num_aggregates
                st.session_state.N = N

    if 'multiple_metrics' in st.session_state:
        metrics = st.session_state.multiple_metrics
        num_aggregates = st.session_state.num_aggregates
        N = st.session_state.N            
        # Show metrics distributions (4 histograms)
        fig, axs = plt.subplots(2, 2, figsize=(24, 16))
        fig.suptitle(f'Distributions for {num_aggregates} aggregates (N={N})', fontsize=14)
        
        fs1 = 24
        fs2 = 20

        # Radius of Gyration
        axs[0, 0].hist(metrics['Rg'], bins=10, alpha=0.7, edgecolor='black',  color='blue')
        axs[0, 0].set_title('Radius of Gyration (Rg)', fontsize = fs1)
        axs[0, 0].set_xlabel('Rg', fontsize = fs1)
        axs[0, 0].set_ylabel('Frequency', fontsize = fs1)
        
        # Shape Factor
        axs[0, 1].hist(metrics['shape_factor'], bins=10, alpha=0.7, edgecolor='black', color='orange')
        axs[0, 1].set_title('Shape Factor', fontsize = fs1)
        axs[0, 1].set_xlabel('Shape Factor', fontsize = fs1)
        axs[0, 1].set_ylabel('Frequency', fontsize = fs1)
        
        # Mass Fractal Dimension (df_v2)
        valid_df_v2 = [x for x in metrics['df_v2'] if not np.isnan(x)]
        if valid_df_v2:
            axs[1, 0].hist(valid_df_v2, bins=10, alpha=0.7, edgecolor='black', color='green')
            axs[1, 0].set_title('Mass Fractal Dimension (df)', fontsize = fs1)
            axs[1, 0].set_xlabel('df', fontsize = fs1)
            axs[1, 0].set_ylabel('Frequency', fontsize = fs1)
            axs[1, 0].set_xlim(1.0, 3.0)  # Typical fractal dimension range
        
        # Porosity
        valid_porosity = [x for x in metrics['porosity'] if not np.isnan(x)]
        if valid_porosity:
            axs[1, 1].hist(valid_porosity, bins=10, alpha=0.7, edgecolor='black', color='red')
            axs[1, 1].set_title('Porosity', fontsize = fs1)
            axs[1, 1].set_xlabel('Porosity (ϵ)', fontsize = fs1)
            axs[1, 1].set_ylabel('Frequency', fontsize = fs1)
            axs[1, 1].set_xlim(0.0, 1.0)
        
        for ax in axs.flatten():
            ax.tick_params('both', labelsize=fs2)
        plt.tight_layout()
        st.pyplot(fig)
    
        # Summary statistics
        st.subheader("Summary Statistics")
        
        col1, col2, col3, col4 = st.columns(4)
        col1.metric("Mean Shape Factor", f"{np.mean(metrics['shape_factor']):.2f}",
                    help="Describes shape. The closer the shape factor to 1, the more point- or sphere-like the particle is.")
        col2.metric("Mean Rg", f"{np.mean(metrics['Rg']):.2f}", 
                    help="Radius of gyration. Describes size. The relationship between $R_g$ and radius of the particle depends on the shape of the particle.")
        
        
        if valid_df_v2:
            col3.metric("Mean Mass Fractal Dim", f"{np.mean(valid_df_v2):.2f}", 
                        help="Fractal dimension. Typical values for this model lie between 1 and 3. The closer this value is to 3, the more compact the particle is. Lower values indicate branching and porosity.")
        else:
            col3.warning("No valid df values")
            
        if valid_porosity:
            col4.metric("Mean Porosity", f"{np.mean(valid_porosity):.2f}", 
                        help="This describes the proportion of empty space in the particle envelope. Likely to be a gross approximation due to the simplified methods used.")
        else:
            col4.warning("No valid porosity values")
    
        st.markdown("---")
        st.subheader("Aggregate Visualization", text_alignment='center')
        st.caption("Select an aggregate to visualize based on its properties", text_alignment='center')

        controls_col, viz_col = st.columns([1, 1])
        
        with controls_col:
            st.subheader("Select metric and visualisation settings")
            st.caption("There should be a sensible caption here eventually")
            metric_selection = st.selectbox("Sort by metric", 
                                        ["Shape Factor", "Radius of Gyration (Rg)", "Mass Fractal Dimension (df)"])

            sort_direction = st.radio("Direction", ["Lowest", "Highest"])
            viz_type_agg = st.selectbox("Visualization type", 
                                   ["Static point cloud", "3D point cloud", "3D spheres (N<201)"])
        
            color_opt_agg = st.selectbox("Color by", ["blue", "addition order", "activity"])
        
            if st.button("Visualize Selected Aggregate"):
                # Find the index of the aggregate to visualize
                metrics_list = st.session_state.multiple_metrics
                if metric_selection == "Shape Factor":
                    values = metrics_list['shape_factor']
                elif metric_selection == "Radius of Gyration (Rg)":
                    values = metrics_list['Rg']
                else:  # Mass Fractal Dimension
                    values = metrics_list['df_v2']
                
                # Filter out NaN values and get valid indices
                valid_indices = [i for i, v in enumerate(values) if not np.isnan(v)]
                valid_values = [values[i] for i in valid_indices]
                
                if not valid_values:
                    st.error("No valid values available for the selected metric.")
                else:
                    # Find the index to visualize
                    if sort_direction == "Lowest":
                        idx_to_visualize = valid_indices[np.argmin(valid_values)]
                    else:
                        idx_to_visualize = valid_indices[np.argmax(valid_values)]
                    
                    # Get the selected aggregate
                    selected_aggregate = st.session_state.multiple_results[idx_to_visualize]
                    selected_metric_value = valid_values[np.argmin(valid_values)] if sort_direction == "Lowest" else valid_values[np.argmax(valid_values)]
                    
                    # Store in session state for visualization
                    st.session_state.selected_aggregate = {
                            'particles': selected_aggregate['particles'],
                            'parameters': selected_aggregate.get('parameters', {}),
                            'metrics': {
                                'shape_factor': metrics_list['shape_factor'][idx_to_visualize],
                                'Rg': metrics_list['Rg'][idx_to_visualize],
                                'df_v2': metrics_list['df_v2'][idx_to_visualize],
                                'porosity': metrics_list['porosity'][idx_to_visualize]
                            },
                            'metric_name': metric_selection,
                            'metric_value': selected_metric_value,
                            'sort_direction': sort_direction,
                            'total_N': selected_aggregate.get('parameters', {}).get('N', len(selected_aggregate['particles']))
                        }
        with viz_col:
            # Display the visualization if an aggregate has been selected
            if 'selected_aggregate' in st.session_state:
                selected = st.session_state.selected_aggregate
                st.subheader(f"Aggregate with {sort_direction} {metric_selection}")
                st.caption(f"Value: {selected['metric_value']:.4f}")
                
                # Get particle positions and radius
                positions = np.array([p['position'] for p in selected['particles']])
                # FIXED: Safe access to radius parameter
                radius = selected.get('parameters', {}).get('radius', 1.0)
                total_N = selected.get('total_N', len(selected['particles']))
                
                # Display visualization based on selection
                if viz_type_agg == "Static point cloud":
                    fig = plot_static(positions, color_opt_agg, selected['particles'], radius, total_N)
                    st.pyplot(fig)
                elif viz_type_agg == "3D point cloud":
                    fig = plot_plotly_points(positions, color_opt_agg, selected['particles'], radius, total_N)
                    st.plotly_chart(fig, use_container_width=True, key=f"agg_viz_point_{color_opt_agg}")
                else:  # 3D spheres (N<201)
                    if len(positions) <= 200:
                        fig = plot_plotly_spheres(positions, color_opt_agg, selected['particles'], radius, total_N)
                        st.plotly_chart(fig, use_container_width=True, key=f"agg_viz_spheres_{color_opt_agg}")
                    else:
                        st.warning("This type of visualisation is not currently supported for an aggregate composed of more than 200 particles. Please choose a different type of visualisation or generate a smaller aggregate.")
                
                # Display metrics for the selected aggregate
                st.subheader("Selected Aggregate Metrics")
                col1, col2, col3, col4 = st.columns(4)
                col1.metric("Shape Factor", f"{selected['metrics']['shape_factor']:.2f}",
                            help="Describes shape. The closer the shape factor to 1, the more point- or sphere-like the particle is.")
                col2.metric("Rg", f"{selected['metrics']['Rg']:.2f}", 
                            help="Radius of gyration. Describes size. The relationship between $R_g$ and radius of the particle depends on the shape of the particle.")
                col3.metric("Df", f"{selected['metrics']['df_v2']:.2f}", 
                            help="Fractal dimension. Typical values for this model lie between 1 and 3. The closer this value is to 3, the more compact the particle is. Lower values indicate branching and porosity.")
                col4.metric("Porosity", f"{selected['metrics']['porosity']:.2f}", 
                            help="This describes the proportion of empty space in the particle envelope. Likely to be a gross approximation due to the simplified methods used.")

                # Save buttons
                col1, col2 = st.columns(2)

                with col1:
                    if st.button("Save XYZ (Selected)"):
                        selected = st.session_state.selected_aggregate
                        filename = f"aggregate_{selected['sort_direction']}_{selected['metric_name'].replace(' ', '_')}.xyz"
                        
                        # Create XYZ content
                        xyz_content = f"{len(selected['particles'])}\n"
                        xyz_content += "Fractal aggregate generated by Streamlit app\n"
                        for p in selected['particles']:
                            pos = p['position']
                            xyz_content += f"C {pos[0]:.6f} {pos[1]:.6f} {pos[2]:.6f}\n"
                        
                        st.download_button(
                            label="Download Selected Aggregate",
                            data=xyz_content,
                            file_name=filename,
                            mime="text/plain"
                        )

                with col2:
                    if st.button("Save All (ZIP)"):
                        import zipfile
                        from io import BytesIO
                        
                        zip_buffer = BytesIO()
                        with zipfile.ZipFile(zip_buffer, "w") as zip_file:
                            for i, result in enumerate(st.session_state.multiple_results):
                                # Create XYZ content
                                xyz_content = f"{len(result['particles'])}\n"
                                xyz_content += f"Fractal aggregate #{i+1} from batch generation\n"
                                for p in result['particles']:
                                    pos = p['position']
                                    xyz_content += f"C {pos[0]:.6f} {pos[1]:.6f} {pos[2]:.6f}\n"
                                
                                # Add to zip
                                zip_file.writestr(f"aggregate_{i+1}.xyz", xyz_content)
                        
                        st.download_button(
                            label="Download All Aggregates (ZIP)",
                            data=zip_buffer.getvalue(),
                            file_name="all_aggregates.zip",
                            mime="application/zip"
                        )

with tabs[4]:
    st.title("Agglomerate Generator")
    st.caption("Generate hierarchical structures by assembling primary aggregates")
    # Parameters section
    with st.expander("Primary Aggregate Parameters", expanded=True):
        col1, col2 = st.columns(2)
        with col1:
            num_primary = st.slider("Number of primary aggregates", 5, 200, 50)
            N_primary = st.slider("Particles per primary aggregate", 10, 500, 100)
            p_primary = st.slider("Inactivation probability (primary)", 0.0, 1.0, 0.1)
        with col2:
            overlap_primary = st.slider("Particle overlap (primary)", 0.0, 0.9, 0.1)
            cell_size_primary = st.slider("Cell size (primary)", 2.0, 10.0, 4.0)
            radius_primary = st.slider("Particle radius (primary)", 0.5, 5.0, 1.0)
    
    with st.expander("Agglomerate Assembly Parameters", expanded=True):
        col1, col2 = st.columns(2)
        with col1:
            use_all = st.checkbox("Use all primary aggregates", value=True)
            N_sub = None
            if not use_all:
                N_sub = st.slider("Number of aggregates to use", 2, num_primary, min(20, num_primary))
        with col2:
            contact_scaling = st.slider("Contact scaling factor", 0.5, 2.0, 1.0)
            macro_beta = st.slider("Macro cell size factor (β)", 1.0, 5.0, 2.5)
            random_seed = st.number_input("Random seed", value=42, min_value=0)
    
    if st.button("Generate Agglomerate", type="primary"):
        with st.spinner("Generating primary aggregates..."):
            primary_aggregates = []
            for i in range(num_primary):
                result = generate_fractal_aggregate(
                    N=N_primary,
                    radius=radius_primary,
                    inactivation_probability=p_primary,
                    overlap=overlap_primary,
                    cell_size=cell_size_primary,
                    random_seed=random_seed + i,
                    visualize=False
                )
                primary_aggregates.append(result)
        
        with st.spinner("Assembling agglomerate..."):
            try:
                # Pass the list of aggregate results directly to generate_agglomerate
                agglomerate_result = generate_agglomerate(
                    aggregates_data=primary_aggregates,
                    N_sub=N_sub if not use_all else None,
                    contact_scaling_factor=contact_scaling,
                    macro_cell_size_beta=macro_beta,
                    random_seed=random_seed,
                    visualize=False,
                    max_particles_for_spheres=200
                )
                st.success("Success! Agglomerate generated successfully.")
            except Exception as e:
                st.error(f"Error generating agglomerate: {str(e)}")