import streamlit as st
import numpy as np
from matplotlib import pyplot as plt
import plotly.graph_objects as go
from io import BytesIO
import os
from fractal_generator import (
    LinkedCellGrid,
    generate_fractal_aggregate,
    calculate_radius_of_gyration,
    calculate_shape_factor
)

# Function to export to XYZ format
def export_to_xyz(particles, filename="aggregate.xyz"):
    with open(filename, 'w') as f:
        f.write(f"{len(particles)}\n")
        f.write("Fractal aggregate generated by Streamlit app\n")
        for p in particles:
            pos = p['position']
            f.write(f"C {pos[0]:.6f} {pos[1]:.6f} {pos[2]:.6f}\n")
    return filename

# Tabs setup
tabs = st.tabs(["Introduction", "Single Aggregate", "Multiple Aggregates", "Agglomerates"])

with tabs[0]:
    st.title("Fractal Aggregate Generator")
    st.markdown("""
    ## Introduction to Fractal Aggregates
    
    This application generates 3D fractal aggregates using the Porous Eden Model.
                
    The algorithm is based on the one described in (1) Guesnet, E.; Dendievel, R.; Jauffrès, D.; Martin, C. L.; Yrieix, B. A Growth Model for the Generation of Particle Aggregates with Tunable Fractal Dimension. Physica A: Statistical Mechanics and its Applications 2019, 513, 63–73. https://doi.org/10.1016/j.physa.2018.07.061.

                
    ## This is a work in progress. "Single Aggregate" tab works.  
    
    ### Mathematical Background
    
    The radius of gyration $R_g$ characterizes the size of the aggregate:
    
    $R_g = \\frac{1}{N}\\sqrt{\\sum_{i<j} r_{ij}^2}$
    
    where $N$ is the number of particles and $r_{ij}$ is the distance between particles $i$ and $j$.
    
    The shape factor is calculated from the eigenvalues of the inertia tensor:
    
    $\\text{Shape Factor} = \\
    sqrt{\\frac{\\lambda_{\\text{max}}}{\\lambda_{\\text{min}}}}$
    
    where $\\lambda_{\\text{max}}$ and $\\lambda_{\\text{min}}$ are the maximum and minimum eigenvalues.
                
    ### To be continued... 
                
    """)

with tabs[1]:
    st.title("Single Aggregate Generator")
    
    # Two-column layout: parameters on left, visualization on right
    col_params, col_viz = st.columns([1, 2])
    
    with col_params:
        st.subheader("Generation Parameters")
        
        N = st.slider("Number of particles", 10, 5000, 500)
        st.caption("Total particles in the aggregate. Larger values increase computation time.")
        
        p = st.slider("Inactivation probability", 0.0, 1.0, 0.05)
        st.caption("Probability that a particle becomes inactive after growth. Higher values create more branched structures.")
        
        overlap = st.slider("Particle overlap", 0.0, 0.9, 0.0)
        st.caption("Fraction of particle diameter allowed to overlap. 0.0 = hard spheres.")
        
        cell_size = st.slider("Cell size", 2.0, 10.0, 4.0)
        st.caption("Spatial grid cell size for efficient collision detection.")
        
        radius = st.slider("Particle radius", 0.5, 5.0, 1.0)
        st.caption("Radius of individual particles in the aggregate.")
        
        if st.button("Generate Aggregate"):
            result = generate_fractal_aggregate(
                N=N,
                radius=radius,
                inactivation_probability=p,
                overlap=overlap,
                cell_size=cell_size,
                visualize=False
            )
            
            # Calculate metrics
            Rg = calculate_radius_of_gyration(result)
            sf = calculate_shape_factor(result)
            
            # Store in session state
            st.session_state.result = result
            st.session_state.Rg = Rg
            st.session_state.sf = sf
            st.session_state.particles = result['particles']
    
with col_viz:
    if 'result' in st.session_state:
        st.subheader("Visualization")
        
        viz_type = st.radio("Visualization type", ["Static point cloud", "Interactive 3D"])
        
        positions = np.array([p['position'] for p in st.session_state.result['particles']])
        radius = st.session_state.get('radius', 1.0)
        
        if viz_type == "Static point cloud":
            # Existing matplotlib code
            fig = plt.figure(figsize=(8, 6))
            ax = fig.add_subplot(111, projection='3d')
            scatter = ax.scatter(positions[:,0], positions[:,1], positions[:,2], s=10, c='blue', alpha=0.8)
            ax.set_box_aspect([1,1,1])
            ax.set_proj_type('persp', focal_length=0.25)
            ax.set_xlabel('X')
            ax.set_ylabel('Y')
            ax.set_zlabel('Z')
            plt.tight_layout()
            st.pyplot(fig)
            
        else:  # Interactive 3D
            fig = go.Figure()
            positions = np.array([p['position'] for p in st.session_state.result['particles']])
            radius = st.session_state.get('radius', 1.0)
            
            if len(positions) <= 200:  # Only render proper spheres for small aggregates
                def ms(x, y, z, radius, resolution=10):
                    """Return coordinates for plotting a sphere centered at (x,y,z)"""
                    u, v = np.mgrid[0:2*np.pi:resolution*2j, 0:np.pi:resolution*1j]
                    X = radius * np.cos(u) * np.sin(v) + x
                    Y = radius * np.sin(u) * np.sin(v) + y
                    Z = radius * np.cos(v) + z
                    return (X, Y, Z)
                
                # Create a surface for each particle
                for pos in positions:
                    x_s, y_s, z_s = ms(pos[0], pos[1], pos[2], radius, resolution=8)
                    fig.add_trace(go.Surface(
                        x=x_s, y=y_s, z=z_s,
                        colorscale=[[0, 'dodgerblue'], [1, 'dodgerblue']],
                        opacity=1,
                        showscale=False,
                        #lighting=dict(ambient=0.5, diffuse=0.8, specular=0.5),
                        #lightposition=dict(x=100, y=200, z=0)
                    ))
            else:
                # For larger aggregates, use scatter with size based on radius
                fig.add_trace(go.Scatter3d(
                    x=positions[:,0], y=positions[:,1], z=positions[:,2],
                    mode='markers',
                    marker=dict(
                        size=8 * radius,  # Scale marker size by particle radius
                        color='dodgerblue',
                        opacity=0.8
                    )
                ))
            
            fig.update_layout(
                scene=dict(
                    xaxis_title='X',
                    yaxis_title='Y',
                    zaxis_title='Z',
                    aspectmode='data'
                ),
                margin=dict(l=0, r=0, b=0, t=0),
                scene_camera=dict(eye=dict(x=1.5, y=1.5, z=1.5))
            )
            st.plotly_chart(fig, use_container_width=True)
        
        # Metrics below visualization
        st.subheader("Aggregate Metrics")
        col1, col2 = st.columns(2)
        col1.metric("Radius of Gyration", f"{st.session_state.Rg:.4f}")
        col2.metric("Shape Factor", f"{st.session_state.sf:.4f}")
        
        # Save XYZ button
        if st.button("Save XYZ"):
            filename = export_to_xyz(st.session_state.particles)
            with open(filename, "rb") as f:
                st.download_button(
                    label="Download XYZ file",
                    data=f,
                    file_name=filename,
                    mime="text/plain"
                )
            st.success(f"Saved to {filename}")